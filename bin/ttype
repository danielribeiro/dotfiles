#!/usr/bin/env bash

# Enable alias expansion in this non-interactive shell context.
shopt -s expand_aliases

# This script determines the type of a command line entry (alias, builtin, function, file, etc.)
# and outputs the result as a structured JSON object.

# NOTE: When run as an executable (./ttype.sh), it runs in a subshell and may not see
# aliases or functions defined interactively unless they are saved in your sourced config files.
# To detect interactively-defined commands, run the script using: . ./ttype.sh <command>

# --- Initialization ---

# FIX: Temporarily set PS1 to a non-empty value to trick the config files into loading
# aliases and functions, and restore the original value immediately after sourcing.

PS1_SAVE="$PS1"
export PS1='__ttype_load_aliases__' # Set to a non-empty value

# Source the appropriate profile file to ensure aliases and functions are loaded.
# We prioritize the standard login/profile files, falling back to bashrc.
if [[ -f ~/.bash_profile ]]; then
  source ~/.bash_profile
elif [[ -f ~/.profile ]]; then
  source ~/.profile
elif [[ -f ~/.bashrc ]]; then
  source ~/.bashrc
fi

# Restore the original PS1 value (good practice, though the script exits shortly)
export PS1="$PS1_SAVE"

# Function to safely get the command type and details in JSON format.
# Requires 'jq' for proper function body string escaping and output formatting.
get_type_json() {
  local command="$1"
  local output
  local json_output='{}'

  # Get the full output from 'type'
  output=$(type "$command" 2>/dev/null)
  local type_exit_code=$?

  if [[ $type_exit_code -eq 0 ]]; then
    if [[ "$output" =~ "aliased to" ]]; then
      # Extract raw alias target.
      local alias_target_raw=$(echo "$output" | sed -E "s/^[^ ]+ is aliased to //")
      local alias_target=$(echo "$alias_target_raw" | sed -E "s/^['\`\"]|['\`\"]$//g")

      # *** FIX: Use jq to safely construct the JSON object for aliases ***
      json_output=$(jq -n \
        --arg cmd "$command" \
        --arg target "$alias_target" \
        '{ ($cmd): { type: "alias", target: $target } }'
      )
    elif [[ "$output" =~ "is a shell builtin" ]]; then
      # Use jq to safely construct the JSON object for builtins
      json_output=$(jq -n \
        --arg cmd "$command" \
        '{ ($cmd): { type: "builtin" } }'
      )
    elif [[ "$output" =~ "is a function" ]]; then
      # 1. Get full definition: declare -f "$command"
      # 2. Remove the first line (function signature): tail -n +2
      # 3. Remove the last line (closing brace '}'): sed '$d'
      local function_body_raw=$(declare -f "$command" 2>/dev/null | tail -n +2 | sed '$d')
      
      # *** FIX: Use jq to safely construct the JSON object for functions ***
      # jq handles all necessary escaping for the body string.
      json_output=$(jq -n \
        --arg cmd "$command" \
        --arg body "$function_body_raw" \
        '{ ($cmd): { type: "function", body: $body } }'
      )
    elif [[ "$output" =~ "is a keyword" ]]; then
      # Use jq to safely construct the JSON object for keywords
      json_output=$(jq -n \
        --arg cmd "$command" \
        '{ ($cmd): { type: "keyword" } }'
      )
    elif [[ "$output" =~ "is" ]]; then
      local path_output=$(type -p "$command" 2>/dev/null)
      if [[ -n "$path_output" ]]; then
        # *** FIX: Use jq to safely construct the JSON object for files ***
        json_output=$(jq -n \
          --arg cmd "$command" \
          --arg path "$path_output" \
          '{ ($cmd): { type: "file", path: $path } }'
        )
      else
        # Unknown type, fallback
        json_output=$(jq -n \
          --arg cmd "$command" \
          --arg raw "$output" \
          '{ ($cmd): { type: "unknown", raw_output: $raw } }'
        )
      fi
    else
      # Unknown type, fallback
      json_output=$(jq -n \
        --arg cmd "$command" \
        --arg raw "$output" \
        '{ ($cmd): { type: "unknown", raw_output: $raw } }'
      )
    fi
  else
    # Command not found
    json_output=$(jq -n \
      --arg cmd "$command" \
      '{ ($cmd): { type: "not_found" } }'
    )
  fi
  
  echo "$json_output"
}

# --- Main Execution ---

# Process each command provided as an argument
if [[ $# -gt 0 ]]; then
  # Check for jq dependency
  if ! command -v jq &> /dev/null; then
      echo "Error: 'jq' is required for this script to function correctly, especially for parsing output." >&2
      exit 1
  fi
  
  for arg in "$@"; do
    echo "--- Type of '$arg' ---"
    # The function now outputs fully formatted JSON, piped directly to jq for pretty printing
    get_type_json "$arg" | jq '.'
    echo ""
  done
else
  echo "Usage: $0 <command1> [command2] ..."
fi